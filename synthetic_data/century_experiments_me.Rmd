---
title: "Hierarchical Bayesian Modeling of CO2 Flux"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Introduction

In this document, we study synthetic soil Carbon data generated by the century model. Each flux data has several replicates, corresponding to different incubation test done on the soil from the same sample. We analyze Bayesian models with complete pooling using a matrix exponential solution. See `century_experiments.pdf` for more information.  

## Century Model

### R code

The R function for simulating the data is shown below. The details are described above.
```{r simulate}
simulate_data_century <- function(t_meas, t_cap, init_C, num_rep) {
# INPUTS: 
#   t_meas:  measurement times
#   t_cap:   cap times
#   init_C:  initial pool contents
#   num_rep: number of replications
library(deSolve)
library(gtools)
genDerivs <-function(t, Ct, params) {
  # General diff eq model: dC_dt = I(t) + A(t)*C(t)
  # INPUTS:
  #   t: time
  #   Ct: the value of the vector C at time t, C(t)
  #   params: it has two fields, params$I and params$A
  dC_dt = params$I + params$A %*% Ct;
  return(list(dC_dt));
}
m <- 3; # number of pools
C_t0 <- matrix(init_C, nrow=m);
turnover <- c(1.5, 25, 1000);
K <- 1/turnover;
I <- rep(0, m); # no input flux for century
N_t <- length(t_meas);
CO2_flux_mat <- matrix(NA, nrow = N_t, ncol = num_rep);
Alpha_rep <- array(0, c(m, m, num_rep));
Alpha <- matrix(0, m, m);
# Setting global transfer rates with expert-tuned values:
Alpha[2, 1] = 0.5;
Alpha[3, 1] = 0.004;
Alpha[1, 2] = 0.42;
Alpha[3, 2] = 0.03;
Alpha[1, 3] = 0.45;
Alpha[1, 1] = 1 - Alpha[2, 1] - Alpha[3, 1];
Alpha[2, 2] = 1 - Alpha[1, 2] - Alpha[3, 2];
Alpha[3, 3] = 1 - Alpha[1, 3] - Alpha[2, 3];
for (this_rep in 1:num_rep) {
  # Hierarchical modeling of transfer rates for replications:
  kappa <- 10;
  Alpha_rep[,1, this_rep] <-  rdirichlet(1, Alpha[,1] * kappa);
  Alpha_rep[,2, this_rep] <-  rdirichlet(1, Alpha[,2] * kappa);
  Alpha_rep[,3, this_rep] <-  rdirichlet(1, Alpha[,3] * kappa);
  Alpha_rep[1, 1, this_rep] <- 0;
  Alpha_rep[2, 2, this_rep] <- 0;
  Alpha_rep[3, 3, this_rep] <- 0;
  A <- Alpha_rep[,, this_rep] * matrix(rep(K, m), nrow = m, byrow = TRUE) - diag(K);
  params <- list(I=I, A=A);
  t0 <- 0;
  # Solving the ODE system for given parameters:
  meas_data<-ode(y = C_t0, func = genDerivs,
          times = c(t0,t_meas), parms = params);
  cap_data<-ode(y = C_t0, func = genDerivs,
                 times = c(t0,t_cap), parms = params);
  # Calculating CO2 flux 
  totalC_t0 = sum(meas_data[1,2:(m+1)]);
  CO2_t_meas <- totalC_t0 - rowSums(meas_data[2:nrow(meas_data), 2:(m+1)]);
  CO2_t_cap <- totalC_t0 - rowSums(cap_data[2:nrow(cap_data),2:(m+1)]);
  CO2_flux <- (CO2_t_meas - CO2_t_cap)/(t_meas-t_cap); 
  # Adding log-normal noise:
  CO2_flux_mat[, this_rep] <- exp(log(CO2_flux) + rnorm(length(CO2_flux),0,.05));
}
simulated_data <- list(N_t = N_t, t_meas = t_meas, t_cap = t_cap, 
                       num_rep = num_rep, totalC_t0 = totalC_t0,
                       t0=t0, CO2_flux=CO2_flux_mat, Alpha_rep=Alpha_rep);
return(simulated_data);
}
```

## Model specification in Stan

We fit the simulated flux replications in the following way:
\item Partial pooling: fitting a hierarchical Bayesian model which estimates parameters jointly for all replications and allows for variation between replicates. The differential equation is solved using a matrix exponential solution.
\end{enumerate}

### Functions

We define `evolved_CO2`, which uses the function `matrix_exp()` to calculate the total evolved (cumulative) CO$_2$ at time $t$.
```
functions { 
  /** 
  * Compute evolved CO2 from the system given the specified 
  * parameters and times. This is done by solving the century
  * model ODE system with a matrix exponential solution and
  * then calculating the rate CO2 is emmited.
  * 
  * @param N_t number of times
  * @param t0 initial time
  * @param ts times
  * @param gamma partitioning coefficient
  * @param k decomposition rates 
  * @param ajk transfer rates
  * @return evolved CO2 for times ts 
  */ 
  vector evolved_CO2(int N_t, real t0, vector ts, 
                     vector gamma, real totalC_t0, 
                     vector k, real a21, real a31, real a12, 
                     real a32, real a13) { 
    vector[3] C_t0;        // initial state 
    matrix[3, 3] A;        // ODE matrix
    vector[3] C_t[N_t];    // predicted pool content
    vector[N_t] CO2_t;     // evolved CO2 at times ts

    A[1, 1] = -k[1];
    A[1, 2] = a12 * k[2];
    A[1, 3] = a13 * k[3];
    A[2, 1] = a21 * k[1];
    A[2, 2] = -k[2];
    A[2, 3] = 0;
    A[3, 1] = a31 * k[1];
    A[3, 2] = a32 * k[2];
    A[3, 3] = -k[3];

    C_t0 = gamma * totalC_t0;

    for (t in 1:N_t) {
      C_t[t] = matrix_exp(ts[t] * A) * C_t0;
      CO2_t[t] = totalC_t0 - sum(C_t[t]); 
    }

    return CO2_t;
  }
}
```

### Data 

The data is also the same for all the models.

```
data { 
  real<lower=0> totalC_t0;      // initial total carbon 
  real t0;                      // initial time 
  int<lower=0> N_t;             // number of measurement times 
  int<lower=0> num_rep;         // number of replicates 
  vector<lower=t0>[N_t] t_meas; // measurement times 
  vector<lower=t0>[N_t] t_cap;  // cap times 
  matrix<lower=0>[N_t, num_rep] CO2_flux; // measured carbon fluxes 
} 
transformed data { 
  real x_r[0];  // no real data for ODE system 
  int x_i[0];   // no integer data for ODE system 
} 
```

Other parts of the stan model are different for different models. In the following, we explain each model in its own section.

### Complete pooling

For the model with complete pooling, we need to define a single set of transfer rate parameters, as all the replications share the same set of parameters. We define simplex vectors `A1`, `A2`, and `A3` and then assign the transfer rates to their elements. The flux is derived by subtracting  the total evolved carbon at times `t_meas` and `t_cap`. 

```
parameters { 
  vector<lower=0>[3] turnover;  // turnover rates
  simplex[3] gamma;             // partitioning coefficients (a simplex) 
  vector<lower=0>[3] sigma;     // turnover standard deviation 
  real<lower=0> sigma_obs;      // observation standard deviation
  simplex[3] A1;                // output rates from pool 1
  simplex[3] A2;                // output rates from pool 2
  simplex[3] A3;                // output rates from pool 3
} 
transformed parameters { 
  vector<lower=0>[3] k;         // decomposition rates (1/turnover)
  vector[N_t] CO2_meas;         // evolved CO2 at measurement times
  vector[N_t] CO2_cap;          // evolved CO2 at cap times
  vector[N_t] CO2_flux_hat;     // CO2 flux (average evolved CO2 between t_cap & t_meas)
  real<lower=0, upper=1> a21;   // transfer rates
  real<lower=0, upper=1> a31;
  real<lower=0, upper=1> a12;
  real<lower=0, upper=1> a32;
  real<lower=0, upper=1> a13;
  k = 1 ./ turnover;
  // transfer rates are the same for all replications:
  a21 = A1[2];
  a31 = A1[3];
  a12 = A2[1];
  a32 = A2[3];
  a13 = A3[1];
  CO2_meas = evolved_CO2(N_t, t0, t_meas, gamma, totalC_t0, 
                          k, a21, a31, a12, a32, a13, 
                          x_r, x_i); 
  CO2_cap = evolved_CO2(N_t, t0, t_cap, gamma, totalC_t0, 
                          k, a21, a31, a12, a32, a13, 
                          x_r, x_i);
  CO2_flux_hat = (CO2_meas - CO2_cap)./(t_meas - t_cap);
} 
```

In the model block, we assign normal distributions to turnovers with mean equal to the expert-tuned variables. We believe that the estimated values should not be too far from the expert-tuned values; so, we set the standard deviations to be $1/10$'th of the mean times a Cauchy random variable. The observation noise is modelled as log-normal with a Cauchy standard deviation.

```
model { 
  // priors 
  turnover[1] ~ normal(1.5, 0.15 * sigma[1]);
  turnover[2] ~ normal(25, 2.5 * sigma[2]);
  turnover[3] ~ normal(1000, 100 * sigma[3]);
  sigma ~ cauchy(0,1); 
  sigma_obs ~ cauchy(0,1);
 
  // likelihood     
  to_vector(CO2_flux) ~ lognormal(to_vector(rep_matrix(log(CO2_flux_hat),num_rep)), sigma_obs);
} 
```

### Partial pool with a hierarchical model

The model specification is similar to the no-pool case with the difference that we now have a set of global trannsfer rates which connects the parameters for different replications. The transformed parameters block is the same as no-pool case and parameters and model block change as follows:

```
parameters { 
  ...
  simplex[3] A1_g;              // global values for rates
  simplex[3] A2_g;              // global values for rates
  simplex[3] A3_g;              // global values for rates
  real<lower=1> kappa;
} 
transformed parameter {
  ...
}
model {
  ...
  kappa ~ normal(100,50);
  for (i in 1:num_rep) {
    A1[i] ~ dirichlet(kappa*A1_g);
    A2[i] ~ dirichlet(kappa*A2_g);
    A3[i] ~ dirichlet(kappa*A3_g);
  }
  ...
}
```

## Fitting the models
```{r fit, message=FALSE, warning=FALSE, cache=TRUE}
num_rep <- 5;
t_meas <- c(seq(from=1/360, to=7/360, by=1/360), seq(from=14/360, to=28/360, by=7/360),
            seq(from=60/360, to=360/360, by=30/360));
t_cap <- c(seq(from=0.5/360, to=6.5/360, by=1/360), seq(from=10.5/360, to=24.5/360, by=7/360),
           seq(from=45/360, to=345/360, by=30/360));
init_C <- c(.1, .1, .8);
data <- simulate_data_century(t_meas, t_cap, init_C, num_rep);

library(rstan);
library(tictoc);
rstan_options(auto_write = TRUE);
options(mc.cores = parallel::detectCores());
tic("hier_me")
fit_hier_me <- stan("century_hier_me.stan", data=data, iter=1500, seed=1234);
t4<-toc()
```


```{r, echo=FALSE, results="hide", message=FALSE, comment=NA}
library(rstan)
ss_hier_me<-summary(fit_hier_me)$summary
```

## initial carbon estimates ($\gamma$)

Actual Values: `gamma[1]=gamma[2]=0.1`, `gamma[3]=0.8`. 

### hierarchical (matrix exponential)

```{r, echo=FALSE, message=FALSE, comment=NA}
print(ss_hier_me[c("gamma[1]", "gamma[2]", "gamma[3]"),], digits = 2)
```

## turnover rates 

Actual Values: 1.5, 25, 1000.

### hierarchical (matrix exponential)

```{r, echo=FALSE, message=FALSE, comment=NA}
print(ss_hier_me[c("turnover[1]", "turnover[2]", "turnover[3]"),], digits = 1)
```


## transfer rates (a21)

Actual Global Value: 0.5 (with variations for each replication)

### pool

### hierarchical (matrix exponential)

```{r, echo=FALSE, message=FALSE, comment=NA}
print(ss_hier_me[c("a21[1]", "a21[2]", "a21[3]", "a21[4]", "a21[5]"),], digits = 2)
```

## transfer rates (a31)

Actual Global Value: 0.004 (with variations for each replication)

### pool

### hierarchical (matrix exponential)

```{r, echo=FALSE, message=FALSE, comment=NA}
print(ss_hier_me[c("a31[1]", "a31[2]", "a31[3]", "a31[4]", "a31[5]"),], digits = 2)
```


## transfer rates (a12)

Actual Global Value: 0.42 (with variations for each replication)

### hierarchical (matrix exponential)

```{r, echo=FALSE, message=FALSE, comment=NA}
print(ss_hier_me[c("a12[1]", "a12[2]", "a12[3]", "a12[4]", "a12[5]"),], digits = 2)
```


## transfer rates (a32)

Actual Global Value: 0.03 (with variations for each replication)

### pool

### hierarchical (matrix exponential)

```{r, echo=FALSE, message=FALSE, comment=NA}
print(ss_hier_me[c("a32[1]", "a32[2]", "a32[3]", "a32[4]", "a32[5]"),], digits = 2)
```


## transfer rates (a13)

Actual Global Value: 0.45 (with variations for each replication)

### hierarchical (matrix exponential)

```{r, echo=FALSE, message=FALSE, comment=NA}
print(ss_hier_me[c("a13[1]", "a13[2]", "a13[3]", "a13[4]", "a13[5]"),], digits = 2)
```


## Plotting fits to data

```{r plot_hier, echo=FALSE}
library(rstan)
library(ggplot2);
fit <- extract(fit_hier_me);
num_rep<-5;
CO2_flux_hat <- array(0,c(data$N_t, num_rep));
CO2_flux_lci <- array(NA,c(data$N_t, num_rep));
CO2_flux_uci <- array(NA,c(data$N_t, num_rep));
for (nr in 1:num_rep) {
  for (t in 1:data$N_t) {
    CO2_flux_hat[t,nr] <- median(fit$CO2_flux_hat[,t,nr]);
    CO2_flux_lci[t,nr] <- quantile(fit$CO2_flux_hat[,t,nr], 0.025);
    CO2_flux_uci[t,nr] <-  quantile(fit$CO2_flux_hat[,t,nr], 0.975);
  }
}
df_plot <- data.frame(list(t_meas = data$t_meas, 
                           CO2_flux_meas = data$CO2_flux,
                           CO2_flux_hat = CO2_flux_hat, CO2_flux_lci = CO2_flux_lci, 
                           CO2_flux_uci = CO2_flux_uci));

ggplot(df_plot, aes(x = t_meas)) +
  geom_ribbon(aes(ymin = CO2_flux_lci[,1],
                  ymax = CO2_flux_uci[,1]),
              fill="lightyellow") +
  geom_line(aes(y=CO2_flux_hat[,1]),colour="darkred") +
  geom_ribbon(aes(ymin = CO2_flux_lci[,2],
                  ymax = CO2_flux_uci[,2]),
              fill="lightyellow") +
  geom_line(aes(y=CO2_flux_hat[,2]),colour="darkred") +
  geom_ribbon(aes(ymin = CO2_flux_lci[,3],
                  ymax = CO2_flux_uci[,3]),
              fill="lightyellow") +
  geom_line(aes(y=CO2_flux_hat[,3]),colour="darkred") +
  geom_ribbon(aes(ymin = CO2_flux_lci[,4],
                  ymax = CO2_flux_uci[,4]),
              fill="lightyellow") +
  geom_line(aes(y=CO2_flux_hat[,4]),colour="darkred") +
  geom_ribbon(aes(ymin = CO2_flux_lci[,5],
                  ymax = CO2_flux_uci[,5]),
              fill="lightyellow") +
  geom_line(aes(y=CO2_flux_hat[,5]),colour="darkred") +
  geom_line(aes(y=data$CO2_flux[,1]),colour="darkblue") +
    geom_line(aes(y=data$CO2_flux[,2]),colour="darkblue") +
  geom_line(aes(y=data$CO2_flux[,3]),colour="darkblue") +
  geom_line(aes(y=data$CO2_flux[,4]),colour="darkblue") +
  geom_line(aes(y=data$CO2_flux[,5]),colour="darkblue") +
  labs(x="Time (days)", 
       y="CO2 flux") +
  ggtitle("Soil Incubation: Century Model (hierarchical-stiff),  \n data (blue), estimate median (red),  95% interval (yellow)");
```
